# -*- coding: utf-8 -*-
"""Traveling Salesman Problem.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pTtylQRfKd2i9H3gjSCnEeDTl0i-A6Cx
"""

import numpy as np, random, operator, pandas as pd
import matplotlib.pyplot as plt

def create_starting_population(size,Number_of_city):
    population = []

    for i in range(0,size):
        population.append(create_new_member(Number_of_city))

    return population

def pick_mate(N):
    i=random.randint(0,N)
    return i

def distance(i,j):
    return np.sqrt((i[0]-j[0])**2 + (i[1]-j[1])**2)

def score_population(population, CityList):
    scores = []

    for i in population:
        #print(i)
        scores.append(fitness(i, CityList))
        #print([fitness(i, the_map)])
    return scores

def fitness(route,CityList):
    #Calculate the fitness and return it.
    score=0
    #N_=len(route)
    for i in range(1,len(route)):
        k=int(route[i-1])
        l=int(route[i])

        score = score + distance(CityList[k],CityList[l])


    return score
def create_new_member(Number_of_city):
    '''
    creating new member of the population
    '''
    pop=set(np.arange(Number_of_city,dtype=int))
    route=list(random.sample(pop,Number_of_city))

    return route
def crossover(a,b):
    child=[]
    childA=[]
    childB=[]


    geneA=int(random.random()* len(a))
    geneB=int(random.random()* len(a))

    start_gene=min(geneA,geneB)
    end_gene=max(geneA,geneB)

    for i in range(start_gene,end_gene):
        childA.append(a[i])

    childB=[item for item in a if item not in childA]
    child=childA+childB




    return child
def mutate(route,probablity):
    #for mutating shuffling of the nodes is used
    route=np.array(route)
    for swaping_p in range(len(route)):
        if(random.random() < probablity):
            swapedWith = np.random.randint(0,len(route))

            temp1=route[swaping_p]

            temp2=route[swapedWith]
            route[swapedWith]=temp1
            route[swaping_p]=temp2

    return route



def selection(popRanked, eliteSize):
    selectionResults=[]
    result=[]
    for i in popRanked:
        result.append(i[0])
    for i in range(0,eliteSize):
        selectionResults.append(result[i])

    return selectionResults

def rankRoutes(population,City_List):
    fitnessResults = {}
    for i in range(0,len(population)):
        fitnessResults[i] = fitness(population[i],City_List)
    return sorted(fitnessResults.items(), key = operator.itemgetter(1), reverse = False)

def breedPopulation(mating_pool):
    children=[]
    for i in range(len(mating_pool)-1):
            children.append(crossover(mating_pool[i],mating_pool[i+1]))
    return children

def mutatePopulation(children,mutation_rate):
    new_generation=[]
    for i in children:
        muated_child=mutate(i,mutation_rate)
        new_generation.append(muated_child)
    return new_generation

def matingPool(population, selectionResults):
    matingpool = []
    for i in range(0, len(selectionResults)):
        index = selectionResults[i]
        matingpool.append(population[index])
    return matingpool

def next_generation(City_List,current_population,mutation_rate,elite_size):

    population_rank=rankRoutes(current_population,City_List)

    #print(f"population rank : {population_rank}")

    selection_result=selection(population_rank,elite_size)
    #print(f"selection results {selection_result}")

    mating_pool=matingPool(current_population,selection_result)
    #print(f"mating pool {mating_pool}")

    children=breedPopulation(mating_pool)
    #print(f"childern {children}")

    next_generation=mutatePopulation(children,mutation_rate)
    #print(f"next_generation {next_generation}")
    return next_generation
def genetic_algorithm(City_List,size_population=1000,elite_size=75,mutation_Rate=0.01,generation=2000):
    pop=[]
    progress = []

    Number_of_cities=len(City_List)

    population=create_starting_population(size_population,Number_of_cities)
    progress.append(rankRoutes(population,City_List)[0][1])
    print(f"initial route distance {progress[0]}")
    print(f"initial route {population[0]}")
    for i in range(0,generation):
        pop = next_generation(City_List,population,mutation_Rate,elite_size)
        progress.append(rankRoutes(pop,City_List)[0][1])


    rank_=rankRoutes(pop,City_List)[0]

    print(f"Best Route :{pop[rank_[0]]} ")
    print(f"best route distance {rank_[1]}")

    return rank_, pop


cityList = []


for i in range(0, 5):
    x=int(random.random() * 100)
    y=int(random.random() * 100)
    cityList.append((x,y))

rank_,pop=genetic_algorithm(City_List=cityList)

x_axis=[]
y_axis=[]
for i in cityList:
    x_axis.append(i[0])
    y_axis.append(i[1])
plt.plot(x_axis,y_axis, linestyle = 'dashed')
plt.show()

import numpy as np
import random

num_cities = 5
num_population = 5
mutation_rate = 0.3

coordinates_list = [[x,y] for x,y in zip(np.random.randint(0,100,num_cities),np.random.randint(0,100,num_cities))]
names_list = np.array(['Europe', 'Asia', 'Antartica', 'Africa', 'Australia'])
cities_dict = { x:y for x,y in zip(names_list,coordinates_list)}

# Function to compute the distance between two points
def compute_city_distance_coordinates(a,b):
    return ((a[0]-b[0])**2+(a[1]-b[1])**2)**0.5

def compute_city_distance_names(city_a, city_b, cities_dict):
    return compute_city_distance_coordinates(cities_dict[city_a], cities_dict[city_b])

print(cities_dict)

# First step: Create the first population set
def genesis(city_list, num_population):

    population_set = []
    for i in range(num_population):
        #Randomly generating a new solution
        sol_i = city_list[np.random.choice(list(range(num_cities)), num_cities, replace=False)]
        population_set.append(sol_i)
    return np.array(population_set)

population_set = genesis(names_list, num_population)
print("\n")
print(population_set)

# First step: Create the first population set
def genesis(city_list, num_population):

    population_set = []
    for i in range(num_population):
        #Randomly generating a new solution
        sol_i = city_list[np.random.choice(list(range(num_cities)), num_cities, replace=False)]
        population_set.append(sol_i)
    return np.array(population_set)

population_set = genesis(names_list, num_population)

print("\n")
print(population_set)

def fitness_eval(city_list, cities_dict):
    total = 0
    for i in range(num_cities-1):
        a = city_list[i]
        b = city_list[i+1]
        total += compute_city_distance_names(a,b, cities_dict)
    return total

def get_all_fitnes(population_set, cities_dict):
    fitnes_list = np.zeros(num_population)

    #Looping over all solutions computing the fitness for each solution
    for i in  range(num_population):
        fitnes_list[i] = fitness_eval(population_set[i], cities_dict)

    return fitnes_list

fitnes_list = get_all_fitnes(population_set,cities_dict)
print("\n")
print(fitnes_list)

def progenitor_selection(population_set,fitnes_list):
    total_fit = fitnes_list.sum()
    prob_list = fitnes_list/total_fit

    #Notice there is the chance that a progenitor. mates with oneself
    progenitor_list_a = np.random.choice(list(range(len(population_set))), len(population_set),p=prob_list, replace=True)
    progenitor_list_b = np.random.choice(list(range(len(population_set))), len(population_set),p=prob_list, replace=True)

    progenitor_list_a = population_set[progenitor_list_a]
    progenitor_list_b = population_set[progenitor_list_b]


    return np.array([progenitor_list_a,progenitor_list_b])


progenitor_list = progenitor_selection(population_set,fitnes_list)
print("\n")
print(progenitor_list[0][2])

def mate_progenitors(prog_a, prog_b):
    offspring = prog_a[0:5]

    for city in prog_b:

        if not city in offspring:
            offspring = np.concatenate((offspring,[city]))

    return offspring



def mate_population(progenitor_list):
    new_population_set = []
    for i in range(progenitor_list.shape[1]):
        prog_a, prog_b = progenitor_list[0][i], progenitor_list[1][i]
        offspring = mate_progenitors(prog_a, prog_b)
        new_population_set.append(offspring)

    return new_population_set

new_population_set = mate_population(progenitor_list)
print("\n")
print(new_population_set[0])

def mutate_offspring(offspring):
    for q in range(int(num_cities*mutation_rate)):
        a = np.random.randint(0,num_cities)
        b = np.random.randint(0,num_cities)

        offspring[a], offspring[b] = offspring[b], offspring[a]

    return offspring


def mutate_population(new_population_set):
    mutated_pop = []
    for offspring in new_population_set:
        mutated_pop.append(mutate_offspring(offspring))
    return mutated_pop

mutated_pop = mutate_population(new_population_set)
print("\n")
print(mutated_pop[0])

print("\n")
best_solution = [-1,np.inf,np.array([])]
for i in range(100):
    if i%10==0: print(i, fitnes_list.min(), fitnes_list.mean())
    fitnes_list = get_all_fitnes(mutated_pop,cities_dict)

    #Saving the best solution
    if fitnes_list.min() < best_solution[1]:
        best_solution[0] = i
        best_solution[1] = fitnes_list.min()
        best_solution[2] = np.array(mutated_pop)[fitnes_list.min() == fitnes_list]

    progenitor_list = progenitor_selection(population_set,fitnes_list)
    new_population_set = mate_population(progenitor_list)
    mutated_pop = mutate_population(new_population_set)

print("\n")
print(best_solution)

